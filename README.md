# GameBlast

Каркас архитектуры игры основан на MVC паттерне. 
Model представлена одноименным файлом. В не реализована главная логика игры.
Главный класс Game создает и менеджит все игровые объекты.
Основная механика игры основана на классах Tile и Field
Поле создает матрицу заданым размером и запалняет его объектами тайлами с заданым количеством вариантов цветов.
Поле "умеет" удалять из сврей матриицы указаные тайлы, сдвигать тайлы в низ на пустые места, заполнять пустые ячейки новыми тайлами, перемешивать тайлы
Класс Game создает поле ивызывает у него необходимые уровни, строит необходимою сцену игры (меню, заданный уровень, пауза, победа, поражение), обсчитывает параметры хода(очки, ходы, прогресс),
принимает решение по выигрышу или проигрышу, перемешивает тайлы в случае, необходимости.
Отдельно стоит описать метод getArrayTilesForBlust(), который проходится от тайла по которому кликнули и собирает все тайлы с таким же цветом.
Поле имеет метод linkTiles() который записывает в параметры каждого тайла ссылки на соседние и устанавливает значение isCounted в false
Мы вызываем метод getArrayTilesForBlustRec() и передаем ему первый тайл и массив куда сложить все соответсвующие тайлы.
Этот метод рекурсивно вызывает себя для всех соседних тайлов с таким же цветом и так далее по цепочке. При вызове нового метода, флаг isCounted ставится в true для замыкания рекурсии
Отрисовка
После каждого этапа манипуляции Game отпровляет данные на отрисовку классу View, при чем на единственый метод facade, этим мы минимизируем зависмость между классами.
Game не заботится как будет отрисованы объекты.
View в зависимости от типа запроса вызывает комбинацию из своих методов. При чем разные элементы отрисовки разбиты на микросервесы, которые мы комбинируем в зависимости от текущей задачи.
Две главные особенности этого метода:
1. При создании объекта мы передаем ему объект с указаными названиями ресурсов и путем для загрузки.
В конструкторе объекта мы вызываем метод начинающий загружать изолбражения и создаем Promise. Дальше все действия по отрисовке только по завршению Promise
2. При вызове отрисовки динамического контнета мы также создаем цепочку из Promise. Это гарантирует коректную очередность анимации.
Также у этого класа есть метод saveState() который сохраняет предыдуще положение объектов, т.к класс Game не ждет отрисовки, а меняеет все параметры сразу.
Условно игра уже выигнрана или проиграна, а View еще рисует.
View при отрисовке устанавливает физические параметры объектов, котроые нужны Controller
Controller
Этот класс вешает обработчик событий на DOM. В нашем случае это только click. Но также Controller может дэтектить любые действия пользователя.
Т.к. отрисовка проходит на canvas у нас нет стандартных HTML API для доступа к объектом отрисовки.
Controller проходит по каждому элементу из objectRegister и создает для него объект Path2D
Затем использую метод canvas isPointInPath проверяем попал ли click на объект.
Затем Controller проверяет на какой объект нажал пользователь и отпровляет его на facade of Game.
Это сделано опять же для минимизации зависимости, ведь controller не может на прямую менять параметры модели. 
